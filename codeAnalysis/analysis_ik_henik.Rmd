---
title: 'MC2: Tracking the embodied dynamics of cognition using computer mouse tracking'
author: "Stefan Scherbaum & Martin Schoemann"
output:
  html_notebook: 
    toc: yes
    highlight: haddock
    theme: flatly
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  error = FALSE
)
```

# Overview

In this [R Markdown](https://rmarkdown.rstudio.com/) notebook, we will have a hands-on look at the embodied dynamics of your own cognition during the [Henik task](https://doi.org/10.3758/BF03202431) which had implemented and ran in [OpenSesame](https://osdoc.cogsci.nl/3.3/) using the [mousetrap plugin](https://github.com/PascalKieslich/mousetrap-os).

Since we have two separate analysis pipelines both in [R](https://www.r-project.org/) and [Matlab](https://www.mathworks.com/products/matlab.html), we will go through both shared and unique analysis steps. As a rough overview, we will cover: 

1. Data import
2. Geometric processing
3. Re-sampling and interpolation
4. Data inspection
5. Summary measures
6. Advanced measures

```{r setup, results='hide'}
library(readbulk)
library(tidyverse)
library(cowplot)
library(mousetrap)

theme_set(theme_bw(base_size = 8, base_family = "") +
            theme(legend.position = "top", 
                  plot.background = element_blank(),
                  panel.grid = element_blank(),
                  strip.text.y=element_text(hjust=0,vjust=1,angle=180),
                  panel.border = element_rect(colour = "black")))
```

# Data import

Our pipeline here in R starts with importing the raw data, combine the single data from each participant, and turning them into a structure that we can easily work with, that is, the [mousetrap](http://pascalkieslich.github.io/mousetrap/index.html) package is optimized for.  

```{r import}
df = read_opensesame(directory = "../dataRaw/", verbose = F) %>% 
  mutate(
    File = parse_number(File) %>% abs()
  ) %>% 
  select(
    p_num = File,
    t_condition = Condition,
    t_bignumber = NumberBig,
    t_smallnumber = NumberSmall,
    t_bignumberposition = NumberPositionBig,
    c_correct = correct,
    timestamps = timestamps_mousetrap_afterhover,
    xpos = xpos_mousetrap_afterhover,
    ypos = ypos_mousetrap_afterhover,
  )
glimpse(df)

mt = df %>% 
  mt_import_mousetrap()
```


# Geometric processing
So, the data are already imported and available in `mt` in convenient structure. 
Now, we look at the cursor trajectories from only one participant in order to learn about:

+ how OpenSesame has tracked the cursor position
+ what geometric processing steps we need to apply
+ to get a feeling for the cursor trajectories 

```{r geometric1}
mt %>% 
  mt_subset(p_num==0) %>% 
  mt_plot()
```

The plot shows the raw cursor trajectories from the participant with `p_num==0`, and we can see that the trajectories were tracked in a somewhat twisted way, that is, the coordinate system in OpenSesame was centered in middle of the screen and going upwards toward the response boxes decreased the y-coordinate. 
We can also see that the trajectories differ in their starting point (i.e., the cursor position in the moment the stimuli were presented) and end point (i.e., the first cursor position in one of the response boxes).
And, we see that trajectories going into different response boxes cannot easily be compared as they end in opposite directions.
Therefore, we remap (`mt_remap_symmetric()`) the trajectories and align their starting point (`mt_align()`).

```{r geometric2}
mt = mt %>% 
  mt_remap_symmetric() %>% 
  mt_align(
    align_start = T,
    align_end = F,
    coordinates = 'norm'
  )

mt %>% 
  mt_subset(p_num==0) %>% 
  mt_plot()
```


# Re-sampling and interpolation
So, the trajectories are in principle comparable but before we can do that in meaningful way, we have to focus on a significant characteristic of such trajectories (well, frankly, that applies to all kinds of time-continuous data), namely, that they are of different lengths.
We cannot easily see that characteristic when we plot the trajectories on the x/y-plane, but when we plot both `xpos` and `ypos` as a function of `timestamps`.

```{r resampling1}
plot_grid(
  mt %>% 
    mt_subset(p_num==0) %>% 
    mt_plot(x = "timestamps", y = "xpos"),
  mt %>%
    mt_subset(p_num==0) %>% 
    mt_plot(x = "timestamps", y = "ypos"),
  nrow = 1,
  labels = NULL
)
```

Different lengths can be due to different sampling frequencies, different times participants took to reach a response box (i.e., because they took short/longer paths or moved the cursor faster/slower), or both.
Both aspects can be treated by re-sampling and interpolation in such a way that each trajectory is represented by an equal number of points.
Time-normalization interpolates trajectories such that they are represented by exactly the same number of temporally equidistant data points (`mt_time_normalize()`), and the number is typically chosen to be 101.
Length-normalization interpolates the trajectory into the same number of spatially equidistant data points (`mt_length_normalize()`).
Another way of representing each trajectory by an equal number of data points is to interpolate the trajectories such that timestamps are equidistant from each other (`mt_resample`) and to fill up each trajectory with its own last data point times the number of data points that are needed to obtain the same length as the longest trajectory in the data (`no such function`); thus the longest trajectory in the data determines the length of all other trajectories and is hence not filled up.

```{r resampling2}
mt = mt %>% 
  mt_time_normalize() %>% 
  mt_length_normalize(n_points = 20) %>% 
  mt_resample(step_size = 50)

# a quick hack to plot ln_trajectories over steps
mt$ln_trajectories = abind::abind(mt$ln_trajectories,t(array(1:20, dim=rev(dim(mt$ln_trajectories)[-3]))),along = 3)
dimnames(mt$ln_trajectories)[[3]][3]="steps"
  
plot_grid(
  mt %>% 
    mt_subset(p_num==0) %>% 
    mt_plot(use = "tn_trajectories", x = "steps", y = "xpos"),
  mt %>% 
    mt_subset(p_num==0) %>% 
    mt_plot(use = "ln_trajectories", x = "steps", y = "xpos"),
  mt %>% 
    mt_subset(p_num==0) %>% 
    mt_plot(use = "rs_trajectories", x = "timestamps", y = "xpos"),
  nrow = 1,
  labels = NULL
)
```


# Data inspection
So, after preprocessing, we need to better understand our data and see whether there are any quirks hidden in it.

## Heat maps
A great way get an overview of the data are heat maps.
A simple way to get a heat map is `mt_heatmap_ggplot()` or just to plot single trajectories transparently.

```{r heatmaps1}
plot_grid(
  mt %>% mt_plot(alpha = .1),
  mt %>% mt_heatmap_ggplot(colors=c("black","darkorange"),verbose = F),
  nrow = 1,
  labels = NULL
)
```
Since we have two conditions of congruency (congruent vs incongruent) in the task, which might affect the movements decisively, it does not hurt to get an impression of the heat maps split up by condition.

```{r heatmaps2}
mt %>% mt_heatmap_ggplot(colors=c("black","darkorange"),verbose = F, facet_col = "t_condition")
```

## Reversals
A typical problem in mouse-tracking studies is that subjects move the mouse backwards to gain some additional space for their decision.
This can be checked by counting the trials in which the mouse moved backwards on the y-axis at any time, captured here in `ypos_flips` given by `mt_measures()`for each subject.
Another problem is that subjects might stop their movement, which logically prevents any cognition to leak into the non-existent movement.
Ideally, all trials would show a movement of a constant speed which would result in a straight movement on the y-axis (though in reality, we know that subjects regularly slow down a bit during stimulus processing).
Hence, we can correlate the real movement on the y-axis with a constant movement on the y-axis and see whether any trials strongly deviate from the constant movement `no such function`.

```{r reversals}
mt = mt %>%
  mt_measures(flip_threshold = 0)

plot_grid(
  mt %>%
    mt_plot(use = "tn_trajectories", x = "steps", y = "ypos", alpha = .1),
  mt %>% 
    mt_aggregate_per_subject(use_variables = "ypos_flips", subject_id = "p_num", .funs = "sum") %>% 
    ggplot(aes(x=1, y=ypos_flips))+
    geom_boxplot()+
    geom_point(position = "jitter", alpha=.1),
  nrow = 1,
  labels = NULL
)
```

## Effects in trajectories
Now we can look qualitatively at the effects of movements between the congruent and the incongruent condition.
Per subject, we take the mean of all movements of one condition.
Note, that we only include trials that were solved correctly.

```{r effectxy}
mt %>% 
  mt_subset(c_correct==1) %>% 
  mt_plot_aggregate(
    use = "tn_trajectories",
    subject_id = "p_num",
    color = "t_condition"
  )
```
The effect is also clearly visible when we only look on the effects on the x-axis, which also allows us to look at the time-course.

```{r effectx}
mt %>% 
  mt_subset(c_correct==1) %>% 
  mt_plot_aggregate(
    use = "tn_trajectories",
    x = "steps", y = "xpos",
    subject_id = "p_num",
    color = "t_condition",
  )
```
If we want a time-course for a measure that integrates X- and Y-movement, we can use the angle.
Since this is a differential measure, it is a bit noisier than X-coordinates.

```{r effectangle}
mt = mt %>% 
  mt_derivatives(use = "tn_trajectories") %>% 
  mt_angles(use = "tn_trajectories", na_replace = T)

mt %>% 
  mt_subset(c_correct==1) %>% 
  mt_plot_aggregate(
    use = "tn_trajectories",
    x = "steps", y = "angle_p",
    subject_id = "p_num",
    color = "t_condition",
  )
```

# Summary measures
So, now we a rather complete picture about how the data look like, and we have a qualitative idea about the effects in the data.
However, in science, we are usually asked to put the observed qualities into quantities.
One way to do that is to use summary measures (or trajectory indices) that summarize characteristics of the trajectories into single values per trial.
Fortunately (or unfortunately), there exist a plethora of such measures focusing on one of three characteristics: curvature, complexity, or time.
Here, we focus on curvature by examining the maximum absolute deviation (MAD) and area under the curve (AUC).

```{r summary}
mt = mt %>% 
  mt_measures()

plot_data = mt$data %>% 
  left_join(
    mt$measures %>% select(mt_id, MAD, AUC),
    by = "mt_id"
  ) 

plot_grid(
  trial_data %>% 
    ggplot(aes(x=t_condition,y=MAD,group=p_num))+
    geom_point(alpha = .1)+
    stat_summary(fun = "mean", geom = "line", alpha = .1)+
    stat_summary(aes(group=1),fun = "mean", geom = "line", alpha = 1, color="steelblue"),
  trial_data %>% 
    ggplot(aes(x=t_condition,y=AUC,group=p_num))+
    geom_point(alpha = .1)+
    stat_summary(fun = "mean", geom = "line", alpha = .1)+
    stat_summary(aes(group=1),fun = "mean", geom = "line", alpha = 1, color="steelblue"),
  nrow = 1,
  label = NULL
)
```


# Advanced measures
A more advanced, but still relatively simple idea is to map the trajectories to predefined prototype trajectories.
By doing this, we focus exclusively on the trajectory shape rather than the temporal evolution and we can dissect and make sense of the heterogeneity that we have observed in the heat maps.

```{r prototypes}
mt = mt %>% 
  mt_map()

plot_grid(
  mt$data %>%
    left_join(mt$prototyping, by = "mt_id") %>% 
    group_by(t_condition, prototype_label) %>%
    summarise(
      n=n(),
      .groups = "drop",
    ) %>%
    mutate(
      perc=n/sum(n),
    ) %>% 
    ggplot(aes(x=t_condition,y=perc,fill=forcats::fct_rev(prototype_label)))+
    geom_bar(stat="identity",color="black")+
    scale_fill_brewer(type="seq", name="Classification", palette = "GnBu", direction = -1)+
    theme(
      legend.position = "right"
    ) +
    guides(fill=FALSE),
  mt_plot(
    mt_prototypes,
    facet_row="mt_id",
    return_type = "plot"
    )+
    ggh4x::facet_grid2(rows = vars(forcats::fct_rev(factor(mt_id,levels=rownames(mt_prototypes)))),
                       strip = ggh4x::strip_themed(background_y = ggh4x::elem_list_rect(fill = rev(RColorBrewer::brewer.pal(5,"GnBu")))))+
    theme(
      axis.text=element_blank(),
      axis.ticks=element_blank(),
      axis.title=element_blank(),
      strip.text.y=element_text(hjust=0,vjust=1,angle=-90),
    ),
  nrow = 1,
  labels = NULL,
  rel_widths = c(3.0,1)
)

# mt %>% 
#   mt_plot(
#   use2 = "prototyping",
#   facet_col = "prototype_label",
#   alpha =.05)
```

# Possible Exercises
*Investigate the influence of another experimental factor!*
For instance, other factors might be the difference between the two numbers, or the congruency of the previous trial.

TODO




