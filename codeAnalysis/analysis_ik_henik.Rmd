---
title: 'MC2: Tracking the embodied dynamics of cognition using computer mouse tracking'
author: "Stefan Scherbaum & Martin Schoemann"
output:
  html_notebook: 
    toc: yes
    highlight: haddock
    theme: flatly
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  error = FALSE,
)
```

# Overview

In this [R Markdown](https://rmarkdown.rstudio.com/) notebook, we will have a hands-on look at the embodied dynamics of your own cognition during the [Henik task](https://doi.org/10.3758/BF03202431) which had implemented and ran in [OpenSesame](https://osdoc.cogsci.nl/3.3/) using the [mousetrap plugin](https://github.com/PascalKieslich/mousetrap-os).

Since we have two separate analysis pipelines both in [R](https://www.r-project.org/) and [Matlab](https://www.mathworks.com/products/matlab.html), we will go through both shared and unique analysis steps. As a rough overview, we will cover: 

1. Data import
2. Geometric processing
3. Re-sampling and interpolation
4. Visualization
5. Summary measures
6. Continuous measures
7. Statistical analysis

```{r setup, results='hide'}
library(readbulk)
library(tidyverse)
library(cowplot)
library(mousetrap)

theme_set(theme_bw(base_size = 8, base_family = "") +
            theme(legend.position = "top", 
                  plot.background = element_blank(),
                  panel.grid = element_blank(),
                  strip.text.y=element_text(hjust=0,vjust=1,angle=180),
                  panel.border = element_rect(colour = "black")))
```

# Data import

Our pipeline here in R starts with importing the raw data, combine the single data from each participant, and turning them into a structure that we can easily work with, that is, the [mousetrap](http://pascalkieslich.github.io/mousetrap/index.html) package is optimized for.  

```{r import}
df = read_opensesame(directory = "../dataRaw/", verbose = F) %>% 
  mutate(
    File = parse_number(File) %>% abs()
  ) %>% 
  select(
    p_num = File,
    t_condition = Condition,
    t_bignumber = NumberBig,
    t_smallnumber = NumberSmall,
    t_bignumberposition = NumberPositionBig,
    c_correct = correct,
    timestamps = timestamps_mousetrap_afterhover,
    xpos = xpos_mousetrap_afterhover,
    ypos = ypos_mousetrap_afterhover,
  )
glimpse(df)

mt = df %>% 
  mt_import_mousetrap()
```


# Geometric processing
So, the data are already imported and available in `mt` in convenient structure. 
Now, we look at the cursor trajectories from only one participant in order to learn about:

+ how OpenSesame has tracked the cursor position
+ what geometric processing steps we need to apply
+ to get a feeling for the cursor trajectories 

```{r geometric1}
mt %>% 
  mt_subset(p_num==0) %>% 
  mt_plot()
```

The plot shows the raw cursor trajectories from the participant with `p_num==0`, and we can see that the trajectories were tracked in a somewhat twisted way, that is, the coordinate system in OpenSesame was centered in middle of the screen and going upwards toward the response boxes decreased the y-coordinate. 
We can also see that the trajectories differ in their starting point (i.e., the cursor position in the moment the stimuli were presented) and end point (i.e., the first cursor position in one of the response boxes).
And, we see that trajectories going into different response boxes cannot easily be compared as they end in opposite directions.
Therefore, we remap (`mt_remap_symmetric()`) the trajectories and align their starting point (`mt_align()`).

```{r geometric2}
mt = mt %>% 
  mt_remap_symmetric() %>% 
  mt_align(
    align_start = T,
    align_end = F,
    coordinates = 'norm'
  )

mt %>% 
  mt_subset(p_num==0) %>% 
  mt_plot()
```


# Re-sampling and interpolation
So, the trajectories are in principle comparable but before we can do that in meaningful way, we have to focus on a significant characteristic of such trajectories (well, frankly, that applies to all kinds of time-continuous data), namely, that they are of different lengths.
We cannot easily see that characteristic when we plot the trajectories on the x/y-plane, but when we plot both `xpos` and `ypos` as a function of `timestamps`.

```{r resampling1}
plot_grid(
  mt %>% 
    mt_subset(p_num==0) %>% 
    mt_plot(x = "timestamps", y = "xpos"),
  mt %>%
    mt_subset(p_num==0) %>% 
    mt_plot(x = "timestamps", y = "ypos"),
  nrow = 1,
  labels = NULL
)
```

Different lengths can be due to different sampling frequencies, different times participants took to reach a response box (i.e., because they took short/longer paths or moved the cursor faster/slower), or both.
Both aspects can be treated by re-sampling and interpolation in such a way that each trajectory is represented by an equal number of points.
Time-normalization interpolates trajectories such that they are represented by exactly the same number of temporally equidistant data points (`mt_time_normalize()`), and the number is typically chosen to be 101.
Length-normalization interpolates the trajectory into the same number of spatially equidistant data points (`mt_length_normalize()`).
Another way of representing each trajectory by an equal number of data points is to interpolate the trajectories such that timestamps are equidistant from each other (`mt_resample`) and to fill up each trajectory with its own last data point times the number of data points that are needed to obtain the same length as the longest trajectory in the data (`no such function`); thus the longest trajectory in the data determines the length of all other trajectories and is hence not filled up.

```{r resampling2}
mt = mt %>% 
  mt_time_normalize() %>% 
  mt_length_normalize(n_points = 20) %>% 
  mt_resample(step_size = 50)

# a quick hack to plot ln_trajectories over steps
mt$ln_trajectories = abind::abind(mt$ln_trajectories,t(array(1:20, dim=rev(dim(mt$ln_trajectories)[-3]))),along = 3)
dimnames(mt$ln_trajectories)[[3]][3]="steps"
  
plot_grid(
  mt %>% 
    mt_subset(p_num==0) %>% 
    mt_plot(use = "tn_trajectories", x = "steps", y = "xpos"),
  mt %>% 
    mt_subset(p_num==0) %>% 
    mt_plot(use = "ln_trajectories", x = "steps", y = "xpos"),
  mt %>% 
    mt_subset(p_num==0) %>% 
    mt_plot(use = "rs_trajectories", x = "timestamps", y = "xpos"),
  nrow = 1,
  labels = NULL
)
```


# Visualization
# Summary measures
# Continuous measures
# Statistical analysis
